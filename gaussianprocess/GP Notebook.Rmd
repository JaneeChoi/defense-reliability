---
title: "GP Fitting of Failure Time of Naval Ships"
author: "Moon, Choi"
link-citations: true
output:
  html_document:
    toc: true
    toc_depth: 5
    toc_float: true
bibliography: biblio.bib
biblio-style: imsmart-nameyear
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1954)
setwd("C:/Users/serim/Documents/academic/여름인턴십/disease_transmission")
```

## 2. Nonparameteric Estimation [비모수 추정]

### 2.1 Spline Function

1) 

Ciprian M. Crainiceanu, Ciprian M. Crainiceanu, M. P. Wand (2005) Bayesian Analysis for Penalized Spline Regression Using WinBUGS

Bayesian inference for nonparametric models enjoys the flexibility of nonparametric models and the exact inference provided by the Bayesian inferential machinery. This paper provides a simple, yet comprehensive, set of programs for the implementation of nonparametric Bayesian analysis in WinBUGS. Good mixing properties of the MCMC chains are obtained by using low-rank thin-plate splines, while simulation times per iteration are reduced employing WinBUGS specific computational tricks.

2) f

### 2.2 Kernel Function

### 2.3 Survival Analysis (Kaplan Meier)

### 2.4 Gaussian Process (GP)

## 3. Gp (time(age)간 거리)

### 3.1




## 1.2 비모수추정 종류는 뭐가 있으며 왜 우리문제는 gp가 유리할까?
## GP Model

$t$: age index 

$j$: ship index

$k[j]$: engine index

$$y_{t,j} \sim N(\mu_{t,j},\sigma)$$
$$\mu_{t,j} = \mu + \theta_t^{\ age}+\theta_j^{\ ship}+\theta_{k[j]}^{\ engine}+\gamma_{t,j}+\delta_{t,\ k[j]}$$

$$\gamma_{j} \sim \text{MultiNormal}(0,K_{l^{\gamma},{\alpha}^{\gamma}})$$
$$\delta_{k} \sim \text{MultiNormal}(0,K_{l^{\delta},{\alpha}^{\delta}})$$
$$\theta_t^{\ age} \sim N(0, {\sigma^{age}}^2)$$
$$\theta_j^{\ ship} \sim N(0,{\sigma^{ ship}}^2\ )$$

$$\theta_k^{\ engine} \sim N(0,{\sigma^{engine}}^2\ )$$




## Stan Model

### data, transformed data block

```{r eval=FALSE}
data {
  int<lower=1> N; //653
  int<lower=1> N_engines; //5
  int<lower=1> N_ships; //99
  int<lower=1> N_ages_obs; // 31
  int<lower=1> N_ages;// 31
  int<lower=1> ship_engine_ind[N_ships];
  int<lower=1,upper=99> ship_ind[N];
  int<lower=1> age_ind[N]; 
  vector[N] y; //
}
transformed data {
  real ages[N_ages];
  for (t in 1:N_ages)
    ages[t] = t;
}
```

### parameters block

```{r eval=FALSE}
parameters {
  matrix[N_ages,N_engines] GP_engine_std;
  matrix[N_ages,N_ships] GP_ship_std;
  vector[N_ages_obs] age_std;
  vector[N_ships] ship_std;
  vector[N_engines] engine_std;
  real<lower=0> tot_var;
  simplex[6] prop_var;
  real mu;
  real<lower=0> length_GP_engine;
  real<lower=0> length_GP_ship;
}
```


* `GP_engine_std`, `GP_ship_std`, `age_std`, `ship_std`, `engine_std` follow standard normal distribution. These are tools for giving Normal prior using cholesky decomposition. 

* `tot_var`and simplex `prop_var` are used to join all $\sigma$s in model in one vector. 

* `mu` is $\mu$ above. ($\mu_{t,j} = \mu + \theta_t^{\ age}+\theta_j^{\ ship}+\theta_{k[j]}^{\ engine}+\gamma_{t,j}+\delta_{t,\ k[j]}$)

* `length_GP_ship`, `length_GP_engine` are length-scale of covariance matrix , i.e. $l^{\gamma}$, $l^{\delta}$. 

### transformed parameters block

```{r eval=FALSE}
transformed parameters {
  matrix[N_ages,N_engines] GP_engine;
  matrix[N_ages,N_ships] GP_ship;

  vector[N_ages_obs] age_re;
  vector[N_ships] ship_re;
  vector[N_engines] engine_re;
  vector[6] vars;

  real sigma_age;
  real sigma_engine;
  real sigma_ship; 

  real sigma_error_ship;

  real sigma_GP_engine;
  real sigma_GP_ship;

  vars = 6 * prop_var * tot_var;
  sigma_age = sqrt(vars[1]);
  sigma_engine = sqrt(vars[2]);
  sigma_ship = sqrt(vars[3]); 
  sigma_GP_engine = sqrt(vars[4]);
  sigma_GP_ship = sqrt(vars[5]);
  sigma_error_ship = sqrt(vars[6]);

  engine_re = sigma_engine * engine_std;
  age_re = sigma_age * age_std;
  ship_re = sigma_ship * ship_std; 
  
  {
    matrix[N_ages, N_ages] cov_engine; 
    matrix[N_ages, N_ages] cov_ship; 
    matrix[N_ages, N_ages] L_cov_engine; 
    matrix[N_ages, N_ages] L_cov_ship; 

    cov_engine = cov_exp_quad(ages, sigma_GP_engine, 
                                  length_GP_engine);
    cov_ship = cov_exp_quad(ages, sigma_GP_ship, 
                                  length_GP_ship);
    for (age in 1:N_ages) {
      cov_engine[age, age] = cov_engine[age, age] + 1e-6;
      cov_ship[age, age] = cov_ship[age, age] + 1e-6;
    }

    L_cov_engine = cholesky_decompose(cov_engine);
    L_cov_ship = cholesky_decompose(cov_ship);
    GP_engine = L_cov_engine * GP_engine_std; 
    GP_ship = L_cov_ship * GP_ship_std;       
  }
}
```

* `sigma_age`, `sigma_engine`, `sigma_ship` are $\sigma^{age}$, $\sigma^{engine}$, $\sigma^{ship}$ above. $\theta_t^{\ age} \sim N(0, {\sigma^{age}}^2)$ 

* `sigma_GP_ship`, `sigma_GP_engine`  are marginal std of covariance matrix of $\gamma_{j}$, $\delta_{k}$ i.e, ${\alpha}^{\gamma}$, ${\alpha}^{\delta}$. 

* `sigma_error_ship` is $\sigma$ of $y_{t,j} \sim N(\mu_{t,j},\sigma)$. 

* `engine_re = sigma_engine * engine_std` means $\theta_k^{\ engine} = \sigma^{engine}\ * N(0,1)$ so that $\theta_k^{\ engine} \sim N(0,{\sigma^{engine}}^2\ )$

* `cov_engine`, `L_cov_engine` are $K_{l^{\delta},{\alpha}^{\delta}}$ and cholesky decomposition $L_{\delta}$ so that $L_{\delta}L_{\delta}^T = K_{l^{\delta},{\alpha}^{\delta}}$

* `GP_engine = L_cov_engine * GP_engine_std` means $\delta_{k} = L_{\delta}*N(0,1)$ so that $\delta_{k} \sim \text{MultiNormal}(0,K_{l^{\delta},{\alpha}^{\delta}})$

### model block

```{r eval=FALSE}

model {
  vector[N] obs_mu;

  for (n in 1:N) {
    obs_mu[n] = mu 
              + age_re[age_ind[n]]                                 
              + engine_re[ship_engine_ind[ship_ind[n]]] 
              + ship_re[ship_ind[n]]   
              + GP_engine[age_ind[n],ship_engine_ind[ship_ind[n]]]  
              + GP_ship[age_ind[n],ship_ind[n]];                   
  }
  y ~ normal(obs_mu, sigma_error_ship); 

  to_vector(GP_engine_std) ~ normal(0, 1);
  to_vector(GP_ship_std) ~ normal(0, 1);
  age_std ~ normal(0, 1);
  ship_std ~ normal(0, 1);
  engine_std ~ normal(0, 1);
  mu ~ normal(.5, .5);
  tot_var ~ gamma(3, 3);
  length_GP_engine ~ weibull(30,8); // value?
  length_GP_ship ~ weibull(30,8);
}
```

```{r eval=FALSE}
  for (n in 1:N) {
    obs_mu[n] = mu 
              + age_re[age_ind[n]]                                 
              + engine_re[ship_engine_ind[ship_ind[n]]] 
              + ship_re[ship_ind[n]]   
              + GP_engine[age_ind[n],ship_engine_ind[ship_ind[n]]]  
              + GP_ship[age_ind[n],ship_ind[n]];                   
  }
```

* above paragraph means $\mu_{t,j} = \mu + \theta_t^{\ age}+\theta_j^{\ ship}+\theta_{k[j]}^{\ engine}+\gamma_{t,j}+\delta_{t,\ k[j]}$

* `y ~ normal(obs_mu, sigma_error_ship)` means $y_{t,j} \sim N(\mu_{t,j},\sigma)$

* `GP_engine_std`, `GP_engine_std`, `age_std`, `ship_std`, `engine_std` follow standard normal because they are used to give normal dist with cholesky. 

* priors for $\mu$, $\frac{\text{sum of all $sigma$ s}}{6}$, $l^{\gamma}$, $l^{\delta}$ are given. 